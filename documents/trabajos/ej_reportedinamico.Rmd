---
title: "Ejemplo reporte dinámico en RMarkdown"
author: "Juan Carlos Castillo"
website: "https://jc-castillo.com/"
output:
  html_document:
    toc: true
    fig_caption: true
---

# Flujo de análisis de datos

El objetivo de este capítulo es presentar mediante un ejemplo un flujo de análisis, con sus




utilizando ELSOC


## Datos y librerías

**A. Librerías**

El procedimiento de análisis en R requiere usualmente cargar librerías para análisis específicos: se instala la librería que se necesita (en caso de no estar ya instalada), y si ya está instalada se carga. Ejemplo, la librería `dplyr`

```{r eval=FALSE}
install.packages("dplyr")  # para instalar
library(dplyr) # para cargar
```

Para hacer más expedito este procedimiento se recomienda utilizar la librería `pacman`, que sirve para instalar y cargar de manera expedita otras librerías. También se recomienda comentar luego de cada librería para qué se va a utilizar, para llevar un registro

```{r}
pacman::p_load(haven, # abrir bases de datos en otros formatos
dplyr, # data management
corrplot # gráfico de correlaciones
)
```

**B. Abrir base de datos**

En caso que las bases estén en formatos separados por comas u otro separador (tabulaciones, espacios):

```{r eval=FALSE}
data <-read.table(ruta/datos,file=".csv",sep="",header=TRUE,row.names=TRUE,col.names=TRUE)
```

Si se encuentran en un formato estándar tipo spss, stata, sas, se utilizan las funciones respectivas de la librería `haven`. En este caso, la base de datos a utilizar (ELSOC) se encuentra en formato Stata, y utilizamos la función `read_dta`. Se da la ruta al archivo local, en este caso la llamamos directamente de la web

```{r}
data<-read_dta("https://juancarloscastillo.github.io/metsoc-facsouchile/documents/data/COESW1_Stata14_V3.dta")
```

Y realizamos un chequeo básico de la lectura de datos: nombres de las variables y tamaño de la base en términos de casos y variables.

```{r}
names(data) # nombre de las variables
dim(data) # dimension de la base
```

## Ajuste de los Datos

Esta parte inicial del análisis es usualmente la más tediosa y la más larga, y consiste en dejar los datos listos para ser analizados. Los procedimientos usuales son selección y renombramiento de las variables, identificación de casos perdidos, recodificaciones y generación de índices simples.

**Selección y renombre de variables**

Este paso es opcional, pero se recomienda por temas de eficiencia. Primero, se identifica el nombre de las variables en el libro de códigos. En segundo lugar se crea un subset que contiene solo las variables que se van a utilizar en el análisis, mediante la función `select` de `dplyr`.

Con esta función se puede además en un paso otorgar un nombre más sustantivo a la variable, que facilite su posterior utilización. En este caso, daremos el nombre sstatus a la variable de estatus subjetivo d1_01, ingreso a m30, educación a m1, y sexo se queda con su nombre. Este subset puede cambiar posteriormente, solo agregar/quitar variables y correr el chunk de código nuevamente

```{r}
data_n <- data %>% select(sstatus = d1_01, ingreso=m30,educacion=m1,sexo)
summary(data_n)
```

**Recodificación de variables**

_Sobre estructura de variables_

En el caso de trabajar con R, el ajuste de las variables pasa por atender el distinto tipo de estructura, usualmente numérico (vector) o variable categórica (factor). Esta definición establece diferencias claras; por ejemplo, no se puede hacer un promedio con un factor, y los vectores númericos no tienen etiquetas. Dado que el límite entre lo categórico y lo continuo muchas veces es más relativo en ciencias sociales, para algunas operaciones resulta más eficiente contar con variables numéricas que puedan tener etiquetas, y que luego puedan ser transformadas a factor para operaciones específicas. En R este formato intermedio se denomina "vector atómico" o "vector etiquetado".

En primer lugar revisaremos la estructura de las variables de la base de datos con el comando `str` (estructura)


```{r}
str(data_n)
```

En este caso, vemos que las cuatro vectores se definen como "haven_labelled", que hace referencia a vectores numéricos etiquetados. Esto ocurre en el proceso de conversión mediante el paquete `haven`, que transforma de esta manera a los valores numéricos con etiqueta que vienen de Stata.
Los vectores que que aparecen aquí se caracterizan por una serie de atributos (attr):

- label: etiqueta de la variable
- format.stata: formato de la etiqueta de la variable
- labels: niveles de respuesta de la variable (values) que están numerados
- names: nombre de las etiquetas de los valores.

Estos atributos luego van a facilitar algunas operaciones de recodificación y de descripción de los datos.

_Proceso de recodificación_

Para que esto sea lo más claro y reproducible posible, para cada variable vamos a comenzar con una descripción inicial, luego las transformaciones necesarias, y una descripción final. Si bien hay una serie de librerías de R asociadas a esto, optamos por la librería `sjmisc`, en primer lugar para minimizar el número de librerías y funciones asociadas, en segundo lugar por su versatilidad en el uso de etiquetas, y finalmente por su compatibilidad con `dplyr`.

```{r}
pacman::p_load(sjmisc)
```

http://strengejacke.de/sjmisc-cheatsheet.pdf

- Estatus subjetivo

```{r}
frq(data_n$sstatus)
```

En el caso de esta variable sabemos por su definición y por el libro de códigos que los valores 88 y 99 corresponden a valores perdidos, que en el caso de R se codifican como `NA`.

```{r}
data_n <- data_n  %>% select(sstatus) %>% na_if(88) %>% na_if(99)
frq(data_n$sstatus)

```

ver combinación de mutate con recode: https://aaroncharlton.com/2018/01/19/transforming-variables-with-dplyr/

sjmisc: https://rdrr.io/cran/sjmisc/man/rec.html

rec(efc$e42dep, rec = "1=1;2=2;3=3;4=4;NA=5"), useNA = "always")


```{r}
na_values(data_n$sstatus) <- c(88,99)
frq(data_n$sstatus)
```
